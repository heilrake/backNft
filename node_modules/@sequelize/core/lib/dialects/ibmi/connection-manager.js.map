{
  "version": 3,
  "sources": ["../../../src/dialects/ibmi/connection-manager.js"],
  "sourcesContent": ["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('connection:ibmi');\nconst parserStore = require('../parserStore')('ibmi');\nconst DataTypes = require('../../data-types').ibmi;\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    this.connections = {};\n    this.lib = this._loadDialectModule('odbc');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    // Combine passed connection options into a connection string\n    // config.port has no real meaning for this ODBC Driver\n    const connectionKeywords = [];\n    if (config.dialectOptions && config.dialectOptions.odbcConnectionString) {\n      connectionKeywords.push(config.dialectOptions.odbcConnectionString);\n    }\n\n    // 'database' doesn't make sense in this context, but it is mapped here to\n    // DSN, which is a close fit\n    if (config.database) {\n      connectionKeywords.push(`DSN=${config.database}`);\n    }\n\n    if (config.username) {\n      connectionKeywords.push(`UID=${config.username}`);\n    }\n\n    if (config.password) {\n      connectionKeywords.push(`PWD=${config.password}`);\n    }\n\n    if (config.host) {\n      connectionKeywords.push(`SYSTEM=${config.host}`);\n    }\n\n    const connectionString = connectionKeywords.join(';');\n    if (connectionString.charAt(connectionString.length - 1) !== ';') {\n      connectionString.concat(';');\n    }\n\n    let connection;\n    try {\n      connection = await this.lib.connect(connectionString);\n    } catch (error) {\n      if (error.toString().includes('Error connecting to the database')) {\n        const err = new SequelizeErrors.ConnectionRefusedError(error);\n        throw (err);\n      }\n    }\n\n    return connection;\n  }\n\n  async disconnect(connection) {\n    return new Promise((resolve, reject) => {\n      if (!this.validate(connection)) {\n        debug('Tried to disconnect, but connection was already closed.');\n        resolve();\n      }\n\n      connection.close(error => {\n        if (error) {\n          reject(error);\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  validate(connection) {\n    return connection.isConnected;\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],
  "mappings": ";AAEA,MAAM,4BAA4B,QAAQ;AAC1C,MAAM,kBAAkB,QAAQ;AAChC,MAAM,EAAE,WAAW,QAAQ;AAE3B,MAAM,QAAQ,OAAO,aAAa;AAClC,MAAM,cAAc,QAAQ,kBAAkB;AAC9C,MAAM,YAAY,QAAQ,oBAAoB;AAE9C,gCAAgC,0BAA0B;AAAA,EACxD,YAAY,SAAS,WAAW;AAC9B,UAAM,SAAS;AAEf,SAAK,cAAc;AACnB,SAAK,MAAM,KAAK,mBAAmB;AACnC,SAAK,kBAAkB;AAAA;AAAA,EAGzB,mBAAmB,UAAU;AAC3B,gBAAY,QAAQ;AAAA;AAAA,EAGtB,mBAAmB;AACjB,gBAAY;AAAA;AAAA,QAGR,QAAQ,QAAQ;AAGpB,UAAM,qBAAqB;AAC3B,QAAI,OAAO,kBAAkB,OAAO,eAAe,sBAAsB;AACvE,yBAAmB,KAAK,OAAO,eAAe;AAAA;AAKhD,QAAI,OAAO,UAAU;AACnB,yBAAmB,KAAK,OAAO,OAAO;AAAA;AAGxC,QAAI,OAAO,UAAU;AACnB,yBAAmB,KAAK,OAAO,OAAO;AAAA;AAGxC,QAAI,OAAO,UAAU;AACnB,yBAAmB,KAAK,OAAO,OAAO;AAAA;AAGxC,QAAI,OAAO,MAAM;AACf,yBAAmB,KAAK,UAAU,OAAO;AAAA;AAG3C,UAAM,mBAAmB,mBAAmB,KAAK;AACjD,QAAI,iBAAiB,OAAO,iBAAiB,SAAS,OAAO,KAAK;AAChE,uBAAiB,OAAO;AAAA;AAG1B,QAAI;AACJ,QAAI;AACF,mBAAa,MAAM,KAAK,IAAI,QAAQ;AAAA,aAC7B,OAAP;AACA,UAAI,MAAM,WAAW,SAAS,qCAAqC;AACjE,cAAM,MAAM,IAAI,gBAAgB,uBAAuB;AACvD,cAAO;AAAA;AAAA;AAIX,WAAO;AAAA;AAAA,QAGH,WAAW,YAAY;AAC3B,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI,CAAC,KAAK,SAAS,aAAa;AAC9B,cAAM;AACN;AAAA;AAGF,iBAAW,MAAM,WAAS;AACxB,YAAI,OAAO;AACT,iBAAO;AAAA;AAGT;AAAA;AAAA;AAAA;AAAA,EAKN,SAAS,YAAY;AACnB,WAAO,WAAW;AAAA;AAAA;AAItB,OAAO,UAAU;AACjB,OAAO,QAAQ,oBAAoB;AACnC,OAAO,QAAQ,UAAU;",
  "names": []
}

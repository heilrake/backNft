{
  "version": 3,
  "sources": ["../src/utils.js"],
  "sourcesContent": ["'use strict';\n\nconst DataTypes = require('./data-types');\nconst SqlString = require('./sql-string');\nconst _ = require('lodash');\nconst baseIsNative = require('lodash/_baseIsNative');\nconst uuidv1 = require('uuid').v1;\nconst uuidv4 = require('uuid').v4;\nconst operators = require('./operators').Op;\n\nconst operatorsSet = new Set(Object.values(operators));\n\nlet inflection = require('inflection');\n\nexports.classToInvokable = require('./utils/class-to-invokable').classToInvokable;\nexports.joinSQLFragments = require('./utils/join-sql-fragments').joinSQLFragments;\n\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\n\nexports.useInflection = useInflection;\n\nfunction camelizeIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\n\nexports.camelizeIf = camelizeIf;\n\nfunction underscoredIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\n\nexports.underscoredIf = underscoredIf;\n\nfunction isPrimitive(val) {\n  const type = typeof val;\n\n  return ['string', 'number', 'boolean'].includes(type);\n}\n\nexports.isPrimitive = isPrimitive;\n\n// Same concept as _.merge, but don't overwrite properties that have already been assigned\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, (objectValue, sourceValue) => {\n    // If it's an object, let _ handle it this time, we will be called again for each property\n    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {\n      // _.isNative includes a check for core-js and throws an error if present.\n      // Depending on _baseIsNative bypasses the core-js check.\n      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {\n        return sourceValue || objectValue;\n      }\n\n      return objectValue;\n    }\n  });\n}\n\nexports.mergeDefaults = mergeDefaults;\n\n// An alternative to _.merge, which doesn't clone its arguments\n// Cloning is a bad idea because options arguments may contain references to sequelize\n// models - which again reference database libs which don't like to be cloned (in particular pg-native)\nfunction merge() {\n  const result = {};\n\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== undefined) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n\n  return result;\n}\n\nexports.merge = merge;\n\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\n\nexports.spliceStr = spliceStr;\n\nfunction camelize(str) {\n  return str.trim().replace(/[\\s_-]+(.)?/g, (match, c) => c.toUpperCase());\n}\n\nexports.camelize = camelize;\n\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\n\nexports.underscore = underscore;\n\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\n\nexports.singularize = singularize;\n\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\n\nexports.pluralize = pluralize;\n\nfunction format(arr, dialect) {\n  const timeZone = null;\n\n  // Make a clone of the array beacuse format modifies the passed args\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\n\nexports.format = format;\n\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\n\nexports.formatNamedParameters = formatNamedParameters;\n\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n\n  return _.cloneDeepWith(obj, elem => {\n    // Do not try to customize cloning of arrays or POJOs\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return;\n    }\n\n    // If we specified to clone only plain objects & arrays, we ignore everyhing else\n    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n    if (onlyPlain || typeof elem === 'object') {\n      return elem;\n    }\n\n    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n    if (elem && typeof elem.clone === 'function') {\n      return elem.clone();\n    }\n  });\n}\n\nexports.cloneDeep = cloneDeep;\n\n/* Expand and normalize finder options */\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));\n  }\n\n  mapOptionFieldNames(options, Model);\n\n  return options;\n}\n\nexports.mapFinderOptions = mapFinderOptions;\n\n/* Used to map field names in attributes and where conditions */\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attr !== 'string') {\n        return attr;\n      }\n\n      // Map attributes to aliased syntax attributes\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n\n      return attr;\n    });\n  }\n\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return options;\n}\n\nexports.mapOptionFieldNames = mapOptionFieldNames;\n\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    attributes = cloneDeep(attributes);\n    for (const attribute of getComplexKeys(attributes)) {\n      const rawAttribute = Model.rawAttributes[attribute];\n\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n\n      if (_.isPlainObject(attributes[attribute])\n        && !(rawAttribute && (\n          rawAttribute.type instanceof DataTypes.HSTORE\n          || rawAttribute.type instanceof DataTypes.JSON))) { // Prevent renaming of HSTORE & JSON fields\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute],\n        }, Model).where;\n      }\n\n      if (Array.isArray(attributes[attribute])) {\n        for (const [index, where] of attributes[attribute].entries()) {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        }\n      }\n\n    }\n  }\n\n  return attributes;\n}\n\nexports.mapWhereFieldNames = mapWhereFieldNames;\n\n/* Used to map field names in values */\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n\n  for (const attr of fields) {\n    if (dataValues[attr] !== undefined && !Model._virtualAttributes.has(attr)) {\n      // Field name mapping\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n\n  return values;\n}\n\nexports.mapValueFieldNames = mapValueFieldNames;\n\n/**\n * Returns whether `value` is using the nested syntax for attributes.\n *\n * @param {string} value The attribute reference to check.\n *\n * @example\n * isColString('$id$'); // true\n * isColString('$project.name$'); // true\n * isColString('name'); // false\n */\nfunction isColString(value) {\n  return typeof value === 'string' && value[0] === '$' && value[value.length - 1] === '$';\n}\n\nexports.isColString = isColString;\n\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);\n}\n\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\n\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\n\nexports.combineTableNames = combineTableNames;\n\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === 'function') {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n\n    return tmp;\n  }\n\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n\n  if (Array.isArray(value)) {\n    return [...value];\n  }\n\n  if (_.isPlainObject(value)) {\n    return { ...value };\n  }\n\n  return value;\n}\n\nexports.toDefaultValue = toDefaultValue;\n\n/**\n * Determine if the default value provided exists and can be described\n * in a db schema using the DEFAULT directive.\n *\n * @param  {*} value Any default value.\n * @returns {boolean} yes / no.\n * @private\n */\nfunction defaultValueSchemable(value) {\n  if (value === undefined) {\n    return false;\n  }\n\n  // TODO this will be schemable when all supported db\n  // have been normalized for this case\n  if (value instanceof DataTypes.NOW) {\n    return false;\n  }\n\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) {\n    return false;\n  }\n\n  return typeof value !== 'function';\n}\n\nexports.defaultValueSchemable = defaultValueSchemable;\n\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n\n  if (omitNull) {\n    const _hash = {};\n\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith('Id') || val !== null && val !== undefined) {\n        _hash[key] = val;\n      }\n    });\n\n    result = _hash;\n  }\n\n  return result;\n}\n\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\n\nconst dialects = new Set(['mariadb', 'mysql', 'postgres', 'sqlite', 'mssql', 'db2', 'ibmi']);\n\nfunction now(dialect) {\n  const d = new Date();\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n\n  return d;\n}\n\nexports.now = now;\n\n// Note: Use the `quoteIdentifier()` and `escape()` methods on the\n// `QueryInterface` instead for more portable code.\n\nconst TICK_CHAR = '`';\nexports.TICK_CHAR = TICK_CHAR;\n\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\n\nexports.addTicks = addTicks;\n\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n\n  return s.replace(new RegExp(tickChar, 'g'), '');\n}\n\nexports.removeTicks = removeTicks;\n\n/**\n * Receives a tree-like object and returns a plain object which depth is 1.\n *\n * - Input:\n *\n *  {\n *    name: 'John',\n *    address: {\n *      street: 'Fake St. 123',\n *      coordinates: {\n *        longitude: 55.6779627,\n *        latitude: 12.5964313\n *      }\n *    }\n *  }\n *\n * - Output:\n *\n *  {\n *    name: 'John',\n *    address.street: 'Fake St. 123',\n *    address.coordinates.latitude: 55.6779627,\n *    address.coordinates.longitude: 12.5964313\n *  }\n *\n * @param {object} value an Object\n * @returns {object} a flattened object\n * @private\n */\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) {\n    return value;\n  }\n\n  const flattenedObj = {};\n\n  function flattenObject(obj, subPath) {\n    for (const key of Object.keys(obj)) {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n      if (typeof obj[key] === 'object' && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    }\n\n    return flattenedObj;\n  }\n\n  return flattenObject(value);\n}\n\nexports.flattenObjectDeep = flattenObjectDeep;\n\n/**\n * Utility functions for representing SQL functions, and columns that should be escaped.\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n *\n * @private\n */\nclass SequelizeMethod {}\n\nexports.SequelizeMethod = SequelizeMethod;\n\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\n\nexports.Fn = Fn;\n\nclass Col extends SequelizeMethod {\n  constructor(col, ...args) {\n    super();\n    if (args.length > 0) {\n      col = args;\n    }\n\n    this.col = col;\n  }\n}\n\nexports.Col = Col;\n\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || '').trim();\n    this.json = json || false;\n  }\n}\n\nexports.Cast = Cast;\n\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\n\nexports.Literal = Literal;\n\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\n\nexports.Json = Json;\n\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === undefined) {\n      logic = comparator;\n      comparator = '=';\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\n\nexports.Where = Where;\n\n// Collection of helper methods to make it easier to work with symbol operators\n\n/**\n * getOperators\n *\n * @param  {object} obj\n * @returns {Array<symbol>} All operators properties of obj\n * @private\n */\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));\n}\n\nexports.getOperators = getOperators;\n\n/**\n * getComplexKeys\n *\n * @param  {object} obj\n * @returns {Array<string|symbol>} All keys including operators\n * @private\n */\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\n\nexports.getComplexKeys = getComplexKeys;\n\n/**\n * getComplexSize\n *\n * @param  {object|Array} obj\n * @returns {number}      Length of object properties including operators if obj is array returns its length\n * @private\n */\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\n\nexports.getComplexSize = getComplexSize;\n\n/**\n * Returns true if a where clause is empty, even with Symbols\n *\n * @param  {object} obj\n * @returns {boolean}\n * @private\n */\nfunction isWhereEmpty(obj) {\n  return Boolean(obj) && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\n\nexports.isWhereEmpty = isWhereEmpty;\n\n/**\n * Returns ENUM name by joining table and column name\n *\n * @param {string} tableName\n * @param {string} columnName\n * @returns {string}\n * @private\n */\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\n\nexports.generateEnumName = generateEnumName;\n\n/**\n * Returns an new Object which keys are camelized\n *\n * @param {object} obj\n * @returns {string}\n * @private\n */\nfunction camelizeObjectKeys(obj) {\n  const newObj = Object.create(null);\n  for (const key of Object.keys(obj)) {\n    newObj[camelize(key)] = obj[key];\n  }\n\n  return newObj;\n}\n\nexports.camelizeObjectKeys = camelizeObjectKeys;\n\n/**\n * Assigns own and inherited enumerable string and symbol keyed properties of source\n * objects to the destination object.\n *\n * https://lodash.com/docs/4.17.4#defaults\n *\n * **Note:** This method mutates `object`.\n *\n * @param {object} object The destination object.\n * @param {...object} [sources] The source objects.\n * @returns {object} Returns `object`.\n * @private\n */\nfunction defaults(object, ...sources) {\n  object = object || Object.create(null);\n\n  for (const source of sources) {\n    if (source) {\n      for (const key of getComplexKeys(source)) {\n        const value = object[key];\n        if (\n          value === undefined\n            || _.eq(value, Object.prototype[key])\n            && !Object.prototype.hasOwnProperty.call(object, key)\n\n        ) {\n          object[key] = source[key];\n        }\n      }\n    }\n  }\n\n  return object;\n}\n\nexports.defaults = defaults;\n\n/**\n *\n * @param {object} index\n * @param {Array}  index.fields\n * @param {string} [index.name]\n * @param {string|object} tableName\n *\n * @returns {object}\n * @private\n */\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName) {\n    tableName = tableName.tableName;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(index, 'name')) {\n    const fields = index.fields.map(\n      field => (typeof field === 'string' ? field : field.name || field.attribute),\n    );\n    index.name = underscore(`${tableName}_${fields.join('_')}`);\n  }\n\n  return index;\n}\n\nexports.nameIndex = nameIndex;\n\n/**\n * Checks if 2 arrays intersect.\n *\n * @param {Array} arr1\n * @param {Array} arr2\n * @private\n */\nfunction intersects(arr1, arr2) {\n  return arr1.some(v => arr2.includes(v));\n}\n\nexports.intersects = intersects;\n\n/**\n * Stringify a value as JSON with some differences:\n * - bigints are stringified as a json string. (`safeStringifyJson({ val: 1n })` outputs `'{ \"val\": \"1\" }'`).\n *   This is because of a decision by TC39 to not support bigint in JSON.stringify https://github.com/tc39/proposal-bigint/issues/24\n *\n * @param {any} value the value to stringify.\n * @returns {string} the resulting json.\n */\nfunction safeStringifyJson(value /* : any */) /* : string */ {\n  return JSON.stringify(value, (key, value) => {\n    if (typeof value === 'bigint') {\n      return String(value);\n    }\n\n    return value;\n  });\n}\n\nexports.safeStringifyJson = safeStringifyJson;\n"],
  "mappings": "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",
  "names": []
}
